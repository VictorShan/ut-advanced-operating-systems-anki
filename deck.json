{
    "__type__": "Deck",
    "children": [],
    "crowdanki_uuid": "4f8e0a7c-be83-11ee-862a-37a7848dbfde",
    "deck_config_uuid": "4f8e0eb4-be83-11ee-862a-37a7848dbfde",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "answerAction": 0,
            "autoplay": true,
            "buryInterdayLearning": true,
            "crowdanki_uuid": "4f8e0eb4-be83-11ee-862a-37a7848dbfde",
            "desiredRetention": 0.9,
            "dyn": false,
            "fsrsWeights": [],
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.0
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": true,
                "delays": [
                    1.0,
                    10.0
                ],
                "initialFactor": 2500,
                "ints": [
                    1,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 50
            },
            "newGatherPriority": 0,
            "newMix": 0,
            "newPerDayMinimum": 0,
            "newSortOrder": 4,
            "replayq": true,
            "rev": {
                "bury": true,
                "ease4": 1.3,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "perDay": 500
            },
            "reviewOrder": 0,
            "secondsToShowAnswer": 0.0,
            "secondsToShowQuestion": 0.0,
            "sm2Retention": 0.9,
            "stopTimerOnAnswer": false,
            "timer": 0,
            "waitForAudio": true,
            "weightSearch": ""
        }
    ],
    "desc": "",
    "dyn": 0,
    "extendNew": 0,
    "extendRev": 0,
    "media_files": [],
    "name": "ut-advanced-operating-systems",
    "newLimit": null,
    "newLimitToday": null,
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "4f8e16d4-be83-11ee-862a-37a7848dbfde",
            "css": ".card {\n    font-family: arial;\n    font-size: 20px;\n    text-align: center;\n    color: black;\n    background-color: white;\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -1775170061518984044,
                    "name": "Front",
                    "ord": 0,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -8523269344021767259,
                    "name": "Back",
                    "ord": 1,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Basic",
            "originalStockKind": 1,
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tmpls": [
                {
                    "afmt": "{{FrontSide}}\n\n<hr id=answer>\n\n{{Back}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "id": 4264313413014856120,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "{{Front}}"
                }
            ],
            "type": 0
        },
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "css": ".card {\n    font-family: arial;\n    font-size: 20px;\n    text-align: center;\n    color: black;\n    background-color: white;\n}\n.cloze {\n    font-weight: bold;\n    color: blue;\n}\n.nightMode .cloze {\n    color: lightblue;\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -933311556917618499,
                    "name": "Text",
                    "ord": 0,
                    "plainText": false,
                    "preventDeletion": true,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": 0
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -3374072642069009193,
                    "name": "Back Extra",
                    "ord": 1,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": 1
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Cloze",
            "originalStockKind": 5,
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tmpls": [
                {
                    "afmt": "{{cloze:Text}}<br><br>\n{{Back Extra}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "id": -6660205170811910628,
                    "name": "Cloze",
                    "ord": 0,
                    "qfmt": "{{cloze:Text}}"
                }
            ],
            "type": 1
        },
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "b21fbb46-c337-11ee-ba01-25ef8c141b52",
            "css": ".card {\n    font-family: arial;\n    font-size: 20px;\n    text-align: center;\n    color: black;\n    background-color: white;\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": -4464610948833463727,
                    "name": "Front",
                    "ord": 0,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "id": 6587438057748758503,
                    "name": "Back",
                    "ord": 1,
                    "plainText": false,
                    "preventDeletion": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false,
                    "tag": null
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Basic (type in the answer)",
            "originalStockKind": 3,
            "req": [
                [
                    0,
                    "any",
                    [
                        0,
                        1
                    ]
                ]
            ],
            "sortf": 0,
            "tmpls": [
                {
                    "afmt": "{{Front}}\n\n<hr id=answer>\n\n{{type:Back}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "id": -4896926577839365357,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "{{Front}}\n\n{{type:Back}}"
                }
            ],
            "type": 0
        }
    ],
    "notes": [
        {
            "__type__": "Note",
            "fields": [
                "Sort in ascending order by access speed: RAM, Hard Disk, Registers, Cache",
                "Registers &gt; Cache &gt; RAM &gt; Hard Disk"
            ],
            "guid": "o;8m*L<qzT",
            "note_model_uuid": "4f8e16d4-be83-11ee-862a-37a7848dbfde",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Is Multiplexing (sharing) hardware resources between applications a function of the OS?",
                "Yes, Multiplexing (sharing) hardware resources between applications a function of the OS"
            ],
            "guid": "p|S3d^}t]3",
            "note_model_uuid": "4f8e16d4-be83-11ee-862a-37a7848dbfde",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does a user process run system commands?",
                "It switches into kernel mode to run system calls"
            ],
            "guid": "kjMohNpR{s",
            "note_model_uuid": "4f8e16d4-be83-11ee-862a-37a7848dbfde",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Where is the information in the registers stored during a context switch?",
                "On the stack"
            ],
            "guid": "Q!n,fW5iO#",
            "note_model_uuid": "4f8e16d4-be83-11ee-862a-37a7848dbfde",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Why don't we have a layer between a process and execution on the processor?",
                "Speed but less safe.<br><br>Not having a layer in between means that processes will have fast direct access to the hardware but not have the safety that having that layer can provide."
            ],
            "guid": "u&hR3u~:&@",
            "note_model_uuid": "4f8e16d4-be83-11ee-862a-37a7848dbfde",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In order for the processors to \"run multiple processes at once\", it is actually using {{c1::Limited Direct Execution::3 words}} for {{c2::time sharing::2 words}}.",
                ""
            ],
            "guid": "w&Ot$3XfWg",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Heaps grows&nbsp;{{c1::up::up/down}} in address space",
                ""
            ],
            "guid": "N)f^Y?^OxT",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "A stack grows {{c1::down::up/down}} in address space",
                ""
            ],
            "guid": "JClBH$RWuo",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<span style=\"color: rgb(237, 51, 59);\">Not</span> adding a layer between the process and the hardware {{c1::increases::increases/decreases}} speed and {{c1::decreases::increases/decreases}} safety",
                "Not having a layer in between means that processes will have fast direct access to the hardware but not have the safety that having that layer can provide."
            ],
            "guid": "MD;27%?;eh",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::timer}} interrupt prevents long running processes from hogging resources",
                ""
            ],
            "guid": "M.qpr`4I:V",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The process usually runs in&nbsp;{{c1::user}} mode but runs in {{c2::kernel}} mode when running system calls",
                "Kernel mode is a \"Privileged State\" that starts off setting up the process before handing it off to user mode."
            ],
            "guid": "sbgfZt~v^}",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The interrupt handler can only be changed in {{c1::kernel}} mode",
                ""
            ],
            "guid": "K20[(OIZ}|",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "System calls from {{c1::user::user/kernel}} mode invoke&nbsp;{{c2::trap}}s that tell the OS to run something in&nbsp;{{c3::kernel::user/kernel}} mode",
                "System looks at the trap table and where the call's arguments are stored to know what to do"
            ],
            "guid": "vv7-R;iV}o",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Which register tracks the next instruction?",
                "eip"
            ],
            "guid": "P~1Z[:a2(l",
            "note_model_uuid": "b21fbb46-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::ebp}} register can be used to traverse back the chain of function calls",
                ""
            ],
            "guid": "hJR$?3yygA",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "What order do programs compile? (Assembler, Compiler, Linker, Loader)",
                "Compiler -&gt; Assembler -&gt; Linker -&gt; Loader"
            ],
            "guid": "d;6h;xW2?h",
            "note_model_uuid": "4f8e16d4-be83-11ee-862a-37a7848dbfde",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "During the start of a function call, a copy of&nbsp;{{c1::ebp::register}} is saved and {{c1::ebp::register}} is overwritten with&nbsp;{{c2::esp::register}}",
                "esp is the stack pointer<br>ebp is the stack frame"
            ],
            "guid": "Grp,E0lvi5",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::strace::Program}} is used to look at system calls a process executes",
                ""
            ],
            "guid": "u6,9I.zR}/",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Timer interrupts}} are used to allow the OS to run when there are long running processes",
                "If it didn't get interrupted, the process could potentially run forever and never exit"
            ],
            "guid": "cAx1EJ[;#:",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::stack}} and the&nbsp;{{c1::heap}} are shared when performing a context switch. Most {{c2::registers}} are shared so their data needs to be saved during context switches",
                ""
            ],
            "guid": "APwHAo:f~Y",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c2::Limited Direct Execution::Specific thing}} is a way for the OS to do&nbsp;{{c1::time sharing}}",
                ""
            ],
            "guid": "pWt*?g5&x]",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::eax}} register holds the&nbsp;{{c2::return value of a function}}",
                ""
            ],
            "guid": "FR8DCHf.`s",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Traps::Traps/Interrupts}} occur when a user program makes a system call or results in an exception; {{c1::Interrupts::Traps/Interrupts}} are initiated by hardware devices",
                ""
            ],
            "guid": "FD<r=|>h_O",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Running time::Metric}}, {{c2::throughput::metric}}, {{c3::fairness::metric}},&nbsp;{{c6::turnaround time}}, and&nbsp;{{c4::response time}} are metrics used to evaulate {{c5::scheduling policies}}",
                "Running time = Actual time the process is running<br>Throughput = Time per process<br>Fairness = Are processes being starved?<br>Response Time = Time to first execution<br>Turnaround time = Total time taken to execute a particular process (including wait)"
            ],
            "guid": "PJ6}m!xJv1",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::FIFO::Scheduling policy}} can have a high {{c2::response time::metric}} in the case where there is a long process followed by short process",
                "If the short process is interactive, that means the user could be waiting for a long time before they can interact again.<br><br>Turnaround time == response time"
            ],
            "guid": "Ayw^!:s_;n",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::SJF::Scheduling policy}} is great for&nbsp;{{c2::response time::metric}} but is dependent on the arrival time of processes",
                "SJF = Shortest Job First<br>This is ideal if all jobs arrive at the same time. If they come sequentially, then it will be the same as FIFO"
            ],
            "guid": "xN7^weKmmu",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::SJCF::Scheduling policy}} will context switch from larger jobs to finish smaller ones first",
                "SJCF = Shortest Job Completed First<br>Determines which jobs are \"larger\" by running time left<br><br>"
            ],
            "guid": "Opj,fReeX%",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The {{c1::Round Robin}} scheduling policy is very fair because every process gets a set amount of time each iteration",
                "Not good response time because it can take a long time for a job to finish if there are many different jobs that all need to execute a bit before we come back to the first one"
            ],
            "guid": "PPKON6`VN0",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Pre-emptive scheduling}} is when a kernel scheduler de-schedules a process post&nbsp;{{c2::timer interrupt::some event}} and schedules another process",
                "Will need to use context switch"
            ],
            "guid": "qD]CCC%hyB",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "When a user space process issues an I/O call, another process&nbsp;{{c1::can::can/cannot}} be scheduled to utilize idle CPU. This&nbsp;{{c2::is not::is/is not}} preemptive scheduling",
                "This is not preemptive scheduling since the OS didn’t stop the user space process from executing further, it was just the fact that the process was waiting for some I/O which allowed the other process to be scheduled."
            ],
            "guid": "hg,h#<j4X@",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::fairness::scheduling metric}} metric considers&nbsp;{{c2::resource allocation}},&nbsp;{{c3::starvation}},&nbsp;{{c4::priority and preemption}},&nbsp;{{c5::scheduling algorithm}} and&nbsp;{{c6::response time for interactive users}}",
                ""
            ],
            "guid": "q:c!`#D^!>",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Response times&nbsp;{{c1::increases::increases/decreases/stays the same}} in SJF as job lengths increase",
                "SJF = Shortest Job First"
            ],
            "guid": "yZ$y1N/Z[~",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Response times&nbsp;{{c1::increases::increases/decreases/stays the same}} in Round Robin as time slice lengths are increased",
                ""
            ],
            "guid": "Ra(hnR|-9y",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Response time::Scheduling metric}} is the time from arrival to first execution while&nbsp;{{c2::turnaround time::scheduling metric}} is the time from arrival to process completion",
                ""
            ],
            "guid": "A;#9rKGFW)",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "There&nbsp;{{c1::is not::is/is not}} a scheduling policy that has both better response times and turnaround times than FIFO, SJF, SJCF, and RR",
                "This is a classic trade-off space and any scheduler which does well in turnaround time metric would perform poorly for response times; moreover a scheduler which does well for some workloads would perform poorly for some other workloads."
            ],
            "guid": "m_N~$Cmew>",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "scheduler"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In&nbsp;{{c1::CFS::scheduling policy}}, a&nbsp;{{c2::heap::data structure}} is used to track the process with the least&nbsp;{{c3::virtual runtime::metric}} to run next",
                "CFS&nbsp; = Completely Fair Scheduler (used in linux kernel)"
            ],
            "guid": "EQV2taxA*W",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "linux-kernel",
                "scheduler"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Virtual runtime::Metric}} is calculated from the&nbsp;{{c2::execution time::metric}} and ideal&nbsp;{{c2::execution time::metric}}",
                "CFS (completely fair scheduler) tries to get the process that was executed the least (lowest VR)<br><br>Additional factors that priority, how many processes are trying to use, how much the processes actually ran, etc. also affect the VR value"
            ],
            "guid": "Bt;ER3cP2J",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "linux-kernel",
                "scheduler"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "When you open a file, the file descriptor will be the&nbsp;{{c1::smallest::random/biggest/smallest}} available number",
                "By default, STDIN is 0, STDOUT is 1, STDERR is 2. You can replace STDOUT by closing that file and opening a different file (which will default to smallest available number 1)"
            ],
            "guid": "c)[;bNJ4+T",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "threads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Every thread has its own&nbsp;{{c1::eip}},&nbsp;{{c2::stack}}, and {{c3::registers}} but they share a&nbsp;{{c4::heap}}",
                "eip = Instruction Pointer"
            ],
            "guid": "FAdRlVo.+]",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "threads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "You&nbsp;{{c1::have to::have to/don't have to}} do context switches for threads",
                "You can only run one thread at a time on a physical processor"
            ],
            "guid": "fJGA){5sxO",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "threads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Reasons to use&nbsp;{{c1::threads}} include higher {{c2::parallelism}} and more efficiently running {{c3::blocking}} operations",
                "It offers more parallelism because thread context switches have less overhead than full process context switches (putting process to sleep, selecting another process, etc)<br><br>IO ops can be more efficient when the process has blocking actions (disk reads) that take a system call where another thread can take over"
            ],
            "guid": "b_}V!k:S=0",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "threads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Threads&nbsp;{{c1::are not::are/are not}} run in the same order they are spawned, which causes&nbsp;{{c2::race conditions::phenomenon}}",
                "The order threads are run depends on what the scheduler decides"
            ],
            "guid": "p.R?M<xGKW",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "threads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The processor has an {{c1::event loop}} that runs&nbsp;{{c2::forever}} and does not cause&nbsp;{{c3::data races}} because the OS is not scheduling anything",
                "Th event loop performs first part of large task and places the rest as an event in a&nbsp;queue to be performed later"
            ],
            "guid": "tiRjy-2;W[",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Using user space scheduling (like&nbsp;{{c1::event loop}}) can be more efficient than OS scheduling and is&nbsp;{{c2::more::more/less}} complex",
                "Applications can schedule instead of the OS. Is more complex because you have to pause and resume processes.&nbsp;"
            ],
            "guid": "os*C[%sp-*",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "events"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Spawning threads can be/is&nbsp;{{c1::expensive::cheap/expensive}} so you can keep a&nbsp;{{c2::pool of threads}} constantly running",
                ""
            ],
            "guid": "zq194|KgPz",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "threads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Nginx uses&nbsp;{{c1::events::threads/events}}",
                ""
            ],
            "guid": "zUZA*0J;-|",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization",
                "events",
                "threads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Mutual exclusion::Idea}} is using&nbsp;{{c2::locks}} to control which processes/threads can read/write to data using {{c3::CAS::hardware primitive}}",
                "CAS = Compare And Swap (View lock, is free?, lock) in one operation, if 2 operations than there can be race conditions"
            ],
            "guid": "Hg@hr)K-^;",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Each process has an&nbsp;{{c1::isolated::shared/isolated}} and {{c2::identical::identical/different}} address range",
                "This means processes can't interfere with each other, can't view another's data, and have predictable address spaces"
            ],
            "guid": "Fvr_O;I>Jc",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Virtual}} system calls avoid doing a full context switch because they are called with&nbsp;{{c2::read-only::read-only/write-only/read-write/no}} access that can be called in {{c3::user::user/kernel}}-space",
                "Example includes minor things like getting current datetime which uses a virtual variable to access value"
            ],
            "guid": "lI]H$&-`pl",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::VDSO}} has better security and is not limited in size",
                "Virtual Dynamic Shared Objects do not have fixed addresses allowing for better flexibility and security"
            ],
            "guid": "?5pRGKj}J",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Bugs in code/Malicious code can cause accesses/writes to another process' memory when using&nbsp;{{c1::static relocation::memory virtualization approach}} due to the offset",
                "Static Relocation allocates chunks of memory to a process and uses an offset to determine the real memory. There is no isolation or ability to reorganize memory because they are all in relation to each other"
            ],
            "guid": "K4D{-iu0%y",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In&nbsp;{{c1::static relocation::memory virtualization approach}}, you can only assign a process' memory once",
                "Static relocation only allows you to set the process' memory range once because every process gets a block of memory. There locations are offset by process-wide memory offset"
            ],
            "guid": "N=r}M}|l3D",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::Base and Bounds::memory virtualization approach}} uses two registers to find the block of memory and isolates process memory and&nbsp;{{c2::allows::allows/doesn't allow}} relocating memory",
                "Base and Bounds uses base offset for the memory block and bounds register to define the max memory. Relocating a process memory involves copying memory and updating the two registers to make room for other processes.&nbsp;"
            ],
            "guid": "bIAiFUA!tE",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Both&nbsp;{{c1::static relocation::memory virtualization approach}} and&nbsp;{{c2::base and bound::memory virtualization approach}} {{c3::incorrectly::correctly/incorrectly}} assumes that a process uses one contiguous block of memory",
                "Most of the process is empty because there is a lot of unused space between the heap, stack and code"
            ],
            "guid": "x@8::n[;;a",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In&nbsp;{{c1::segmentation::memory virtualization approach}} involves splitting the process memory into 3 parts&nbsp;{{c2::code, heap, stack::regions of process memory}}",
                "Each of these segments can be stored separately that are intermixed (P1stack, P2stack, P2heap,P1code...) which allows more of the physical memory to be used"
            ],
            "guid": "iShCg[*`+h",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::segmentation::memory virtualization approach}} is an extension of the {{c2::base and bounds::memory virtualization approach}} except it uses two extra&nbsp;{{c3::registers}} for a memory block to determine {{c4::direction}} and {{c5::permissions}}",
                "An extra register determines the direction to know which way the memory grows (down for stack, up for heap and code). Another register determine permissions for memory segment"
            ],
            "guid": "hef[]+H!VV",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In&nbsp;{{c2::segmentation::memory virtualization approach}}, the {{c1::memory address}} determines whether it is the code, stack or heap",
                "This can be encoded with (first) two bits of the memory address (3 options). This uses very little memory to determine"
            ],
            "guid": "QLxkvO#hC]",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In memory virtualization, all the registers used to keep track of memory blocks are&nbsp;{{c1::saved::saved/lost}} during context switch",
                ""
            ],
            "guid": "F10fn6[,UU",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Fragmentation}} is&nbsp;unallocated memory between allocated blocks that cannot be used but can be fixed/removed by an expensive&nbsp;{{c2::compacting}} operation",
                "Fragmentation usually happens to small chunks of memory.<br>Compacting copies large chunks of memory so they are expensive to perform.<br>Happens in segmentation, base and bounds, and static relocation"
            ],
            "guid": "io&?Tud~Yn",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Heap&nbsp;{{c1::is not::is/is not}} often consumed as a growing block",
                "Heap doesn't grow like the stack does.&nbsp; This is because of allocating and deallocating from malloc and free"
            ],
            "guid": "o]Nb-2[!xq",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Using paging, we {{c1::will not::will/will not}} need to copy entire stacks/heaps/code around to defragement",
                "This is because we can just allocate unused pages and assign them to a different process so there is no need for widescale copying for defragmentation"
            ],
            "guid": "p6?W{sl2|n",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "A page is usually&nbsp;{{c1::4kb::storage size}} in modern systems",
                ""
            ],
            "guid": "c~YUbFJm^v",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Using pages reduce&nbsp;{{c1::external fragmentation}} but causes {{c2::internal fragmentation}}",
                "There can be fragmentation within pages. Reducing page size reduces fragmentation but increases page table size"
            ],
            "guid": "D:]-}kg612",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "This first part of the virtual address is the&nbsp;{{c3::page directory entry}} followed by the {{c1::page table entry}} and finally the {{c2::physical memory offset}}",
                "Virtual page is translated to physical page and then the offset is applied.<br><br>10 bits for page directory entry<br>10 bits for paget table entry<br>12 bits for physical offset"
            ],
            "guid": "bj1YKa<5hK",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "A page table includes mappings for {{c1::allocated::allocated/all}} virtual pages",
                "Some virtual addresses may not be mapped to physical pages. There is an extra valid bit column"
            ],
            "guid": "pin:XRKP<^",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::OS}} is responsible for allocating and freeing physical pages",
                ""
            ],
            "guid": "sbJC[QW|%C",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The page table is stored in&nbsp;{{c1::memory}} (located at the address stored in {{c3::PTBR}}) and {{c2::MMU}} uses it to translate from virtual to physical address and read its contents",
                "MMU = Memory Management Unit (Hardware)<br>PTBR = Page Table Base Register points to start of page table (privileged register)"
            ],
            "guid": "i+B8}$EsL;",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "If the page table contains all pages, accessing physical address costs&nbsp;{{c1::2::number}} memory accesses.&nbsp;{{c2::TLB}} solves this this",
                "1. Acccess to get page translation 2. Access to get content at physical address<br>TLB = Translation Lookahead Buffer"
            ],
            "guid": "kC)-9,#I~k",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::TLB}} can be thought of a small cache for page table entries that's much faster than DRAM",
                "Translation Lookaside Buffer is used to cache page table entries to avoid memory access"
            ],
            "guid": "4ONxGH|(4",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Temporal Locality}} is the tendency for programs to access memory near where it has already read",
                "This is what makes Translation Lookaside Buffer work because it is much smaller and temporal locallity means that the cache entries are used frequently. We avoid looking at page table. Caching is performed in hardware"
            ],
            "guid": "QSLwj6.D/<",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Processes access page tables more often after context switches because the&nbsp;{{c1::TLB}} was flushed",
                "Translation Lookaside Table is flushed during context switches so processes are slower after switches"
            ],
            "guid": "lKdm3j/}%1",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In a virtual address, the first 10 bits is the&nbsp;{{c1::page table directory}} and the next 10 is the&nbsp;{{c2::page table entry}} and the final 12 is the&nbsp;{{c3::memory offset}}",
                ""
            ],
            "guid": "myH7&j0SK;",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "A page directory saves space because&nbsp;{{c1::some::some/all}} tables are allocated",
                "A bit tells us if the page directory entry is an allocated page table. This saves space because we can omit whole sub-tables from allocation thus saving on the space because not all memory needs to be mapped."
            ],
            "guid": "F!_Z%hra<+",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Without&nbsp;{{c1::TLB}},&nbsp;{{c2::multi-level page tables}} would be slower than one big page table",
                "Translation lookaside buffer caches entries so it makes the two memory accesses from using multi level tables less expensive"
            ],
            "guid": "fq6uRqjuDI",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::CR3}} register holds the address to the page table directory",
                "This needs to be stored and restored during context switches"
            ],
            "guid": "y?aA!#)8J:",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In 64 bit system, the top&nbsp;{{c1::16}} bits are not used and the address will only be the last&nbsp;{{c2::48}} bits",
                "The 48 bits are separated into 9 bit global directory, 9 bit upper, 9 bit middle, 9 bit lower directories and 12 bit offset. All translations done in hardware"
            ],
            "guid": "vUYE@O}7Yl",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "A&nbsp;{{c1::page fault}} happens when a virtual address cannot be translated to a physical address",
                "Using a 'present' flag in the page table entry. We don't want to allocate&nbsp;\\(2^{32}-1\\)&nbsp;bytes (4GB) for every process."
            ],
            "guid": "zo`NQk],kw",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "When a page fault happens, the&nbsp;{{c1::hardware}} will call the&nbsp;{{c2::OS}} to allocate physical memory",
                "Page faults are expensive"
            ],
            "guid": "O]*qQ$ZDF8",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Page faults are expensive becaues they involve the OS&nbsp;{{c1::finding free physical memory}},&nbsp;{{c2::page walk}}, and {{c3::changing entry in table}}",
                "Page walk is needed to find the page table entry that repsents that address. That entry then needs to be changed. We can pre-fault pages to pre-allocate them"
            ],
            "guid": "IZr}4y2dOy",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "To avoid page faults, you can&nbsp;{{c1::pre-fault}} by&nbsp;{{c2::writing/reading 1 bit to every page}}",
                ""
            ],
            "guid": "NBc0@j8RJT",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "If you run out of physical memory, you can store pages in&nbsp;{{c1::storage}} and your system will&nbsp;{{c2::slow down::speed up/slow down}}",
                "Storage includes Hard disk or USB, or other slower memory. It will slow down because accessing those swapped out pages is very slow because it has to be swapped back first"
            ],
            "guid": "ORp7;{pk]T",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Common page swapping strategies include&nbsp;{{c1::LRU}} and {{c2::FIFO}}",
                "LRU = Least Recently Used<br>FIFO = First In First Out"
            ],
            "guid": "imBo?C_d@F",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::mmap}} systemcall allows you to directly control your virtual memory address",
                "Man def: program allocates memory, or map files or devices onto memory"
            ],
            "guid": "iq>5yTy,t8",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The&nbsp;{{c1::mmap}} system call is very barebones. It maps physical address space to your own address space",
                "Does all the page table edits needed to allocate that page. It cal also allow you to map physical memory used by other processes (shared page can be used for communication)"
            ],
            "guid": "d?I0={26Q;",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "When mmap maps a file, it uses the OS {{c1::page cache}} to map the cached version.",
                "Use msync to sync changes to storage"
            ],
            "guid": "w,*mAS]_bp",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c2::malloc}} uses a {{c1::heap allocator}} to find the best or first memory chunk that fits",
                ""
            ],
            "guid": "GeRA(8_kSN",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "How does free know how much memory to free when only given pointer address?",
                "There's a header section before the point address returned that tells use the size"
            ],
            "guid": "P%|{%n+HfO",
            "note_model_uuid": "4f8e16d4-be83-11ee-862a-37a7848dbfde",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "When using {{c1::garbage collection}}, the memory can only be freed after there are 0&nbsp;{{c2::references}} left",
                "Garbage collection might not happen immediately after there are 0 reference. You must wait for it to happen to reclaim space"
            ],
            "guid": "v(nYgs,{BL",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The disadvantages of {{c3::huge pages}} include high page {{c2::fault latency}} and {{c1::memory bloating}}",
                "Also unfair huge page allocation and uncoordinated memory management"
            ],
            "guid": "gvvKt5yRAL",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "memory-virtualization",
                "paging"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "&nbsp; Ingens {{c1::asynch::sync/async}}onously allocates huge pages",
                "It allocates the rest in the background by shuffling pages around"
            ],
            "guid": "g&zz*^{_Hy",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Ingens groups {{c1::continous}} allocated virtual memory into {{c2::one huge page}} to reduce page table entries",
                ""
            ],
            "guid": "ly,cksZqr@",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "cpu-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Tape}} is the cheapest long term storage option",
                "Costs about 1 cent per GB. Requires rewinding to read previous data."
            ],
            "guid": "GRFCkqGwT2",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Magnetic Hard Drives}} have good capacity but has slow latency 10ms",
                "Not as reliable and more expensive tape but much faster. Not fast enough for services."
            ],
            "guid": "F6C25~(9Mi",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Hard drives}} has many moving parts but&nbsp;{{c2::SSD}}s have no moving parts and are much faster",
                "Hard drive latency is at 10ms while SSD latency is at 20-100us"
            ],
            "guid": "t+V,hy}fn4",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Persistent Memory}} has 100-500ns latency and is much faster than both SSD and HDD",
                ""
            ],
            "guid": "Oy4nOJ66XI",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "A&nbsp;{{c1::file::abstraction}} is a linear series of bytes",
                ""
            ],
            "guid": "4A!}Dz*kx",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The two goals file systems struggle with are&nbsp;{{c1::performance}} and&nbsp;{{c2::reliablility}}",
                "File systems need to be performant and they need files to continue existing if there is a power outage"
            ],
            "guid": "JpaHi6q8eU",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Polling}} to access storage devices has low latency but wastes CPU cycles",
                ""
            ],
            "guid": "w[00<:+=wq",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Interrupts}} have higher {{c2::latency&nbsp;}} when accessing storage devices but uses fewer&nbsp;{{c3::CPU cycles}}",
                "CPU may not know that device is available until the next interrupt"
            ],
            "guid": "b`VebMFD7q",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "CPU can setup the memory and device buffers for the device so it can transfer data using&nbsp;{{c1::Direct Memory Access}}",
                ""
            ],
            "guid": "pp>`,Vq]zy",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In a {{c1::HDD}}, the disk is divided into {{c2::tracks}}, which are divided into {{c3::sectors}}",
                "A track runs along the disk like circumference. A sector is a section of that track. The speed of access relies on RPM seek time and transfer time<br>"
            ],
            "guid": "FkF@Sccbw7",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "To calculate the speed of HDD, you need the sum of {{c3::seek time}}, {{c2::rotation time}},&nbsp; and {{c1::transfer time}}",
                "<ul><li>Rotation time is the rotation speed of the disk</li><li>Seek time is repositioning the head to the correct track (2ms)</li><li>Transfer time depends on how dense your data is</li></ul>"
            ],
            "guid": "IXVgq;$U+f",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::SSD}}s are composed of {{c2::flash cells}} that store data by adding electrons to a floating gate",
                "To read, we must see the amount of electrons in the cell. Multi level cells can store multiple bits by the amount of electrons in the cell"
            ],
            "guid": "uT+S%XXUn<",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c3::SSD}}s contain {{c1::NAND}} (cheaper, lower latency) and {{c2::NOR}} (finer grained access) flash cells",
                ""
            ],
            "guid": "dnd{tez%df",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::SSD}}s is a {{c4::flash package}} connected to a {{c5::I/O Bus}}. It has&nbsp;multiple '{{c2::die}}'s which contain multiple {{c3::planes}} which contain blocks and a register.",
                "Dies can run in parallel<br>Some operations can be run concurrently in planes"
            ],
            "guid": "k|NS_c2}0*",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In {{c1::SSD}}s, {{c2::Blocks}} can be erased, {{c3::pages}} can be written and read",
                "<div>The entire block needs to be copied to another block before it can be updated because it will be erased an rewritten</div><ul><li>Small block Single Level Cell: Block size 16KB, Page size 512 bytes</li><li>Large-block Multi LC: Block size 512 KB, Page size 4KB</li></ul><div>There are also Out Of Bounds (OOB) bytes for every page (16-128 bytes) used for checksums.</div>"
            ],
            "guid": "A$K<^z^|sj",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "To update, {{c1::SSD}}s must erase than write.",
                "<ul><li>SSDs only writes by changing 0 to 1 (adding charge) so it must erase the entire block before writing.</li><li>There is a limited number of possible writes an SSD flash cell can perform (10^6)</li><li>Reads are faster than writes due to this</li></ul>"
            ],
            "guid": "vSM$?,TKvi",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The {{c1::FTL}} translates the logical pages in the {{c2::SSD}} to physical pages. Located on the {{c3::device::host/client}}",
                "Flash Translation Layer (FTL) also:<br><ul><li>Garbage collects old pages</li><li>Wear leveling management by choosing pages carefully and spread out writes so wear is equal</li><li>Parallel IO</li><li>Error handling</li></ul><div>Research SSDs can have FTL on the host instead of the device</div>"
            ],
            "guid": "nc0W3Z*no!",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c2::Crash recovery}} refers to ensuring data {{c1::integrity}} in file systems even after system crashes or power loss.",
                ""
            ],
            "guid": "euvOr,Z68s",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Most storage systems lack an {{c1::atomic}} multi-block primitive, leading to potential data inconsistencies during file system operations.",
                ""
            ],
            "guid": "zVUuoW^UAI",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Creating a new file involves updating multiple components on storage, such as the {{c1::inode}}, {{c2::directory}}, and {{c3::inode bitmap}}.",
                "Failure to complete these updates due to a crash can result in storage leakage or data corruption."
            ],
            "guid": "B,&c7rYGzF",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "File systems use {{c1::transactions}} to ensure {{c2::atomicity}} and {{c3::durability}} of updates, guaranteeing that either all updates within a transaction are persisted or none of them are.",
                ""
            ],
            "guid": "vndS^wS(f~",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "A {{c2::crash-consistent}} file system ensures that critical data structures remain intact despite crashes, preventing issues like {{c1::double allocation}} of blocks or inodes.",
                ""
            ],
            "guid": "@Vv_*yaQ#",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "While users prioritize data {{c1::integrity}} and {{c2::accessibility}} after a crash, {{c3::crash consistency}} primarily focuses on preserving file system integrity rather than data.",
                ""
            ],
            "guid": "g(J^&wQ9#Z",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Most file systems protect data from {{c3::corruption}} even after a crash, although data {{c2::availability}} may depend on proper {{c1::synchronization}} between memory and storage.",
                ""
            ],
            "guid": "j<{p0Hz3Ms",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "File systems provide security measures, such as {{c1::zeroing out}} data blocks before reallocation to prevent {{c2::unauthorized access}} to sensitive information.",
                ""
            ],
            "guid": "k=%hiue<W)",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Modern file systems offer more than just crash {{c1::consistency}}, providing additional features for data protection and security.",
                ""
            ],
            "guid": "fUDR!G&t{E",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Crash consistency in modern file systems relies on two main techniques: {{c1::Logging}} and {{c2::Shadow Paging}}.",
                ""
            ],
            "guid": "k;3w2Lx|/Q",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Logging and Shadow Paging ultimately aim to ensure {{c1::atomicity}} and {{c2::consistency}} in file system modifications by employing {{c3::copy}}-based strategies.",
                ""
            ],
            "guid": "hjOcl]0GGm",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Logging involves writing data to a log before {{c1::committing}} it to the actual file system. A special commit block ensures {{c2::atomicity}}.",
                "Logging, originating from the database community, writes data to a log before committing changes,"
            ],
            "guid": "oQ767+j8Ut",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Shadow Paging}} organizes information in a {{c2::tree}} structure and creates copies of modified data blocks along with their parent nodes.",
                "<ul><li>Changes are finalized by atomically switching to the new tree structure.</li><li>Shadow Paging, historically used for providing transactions, creates new subtrees to reflect modifications.</li></ul>"
            ],
            "guid": "A<pyW7#lQA",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Logging}} typically requires {{c2::less::more/less}} overhead for metadata operations but might incur {{c3::additional::additional/fewer}} write amplification due to writing changes twice (once to the log and once to the file system)",
                "<ul><li>ext4 and xv6 use Logging</li><li>can be efficient for systems with high write throughput because it allows changes to be batched and written sequentially to the log<br></li></ul>"
            ],
            "guid": "ly~:KXj=an",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Shadow Paging}} may involve more {{c2::complex::simple/complex}} metadata management due to the tree structure and the need to manage pointers effectively",
                "<ul><li>Examples of file systems employing Shadow Paging and copy-on-write techniques include btrfs and ZFS.</li><li>minimize write amplification compared to Logging because modifications are written directly to new data blocks without needing to be duplicated in a log<br></li></ul>"
            ],
            "guid": "o)>Wd|cU0{",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Hardware}} support is crucial for crash recovery in file systems due to complexities introduced by storage devices.",
                ""
            ],
            "guid": "t7N%hj.uy8",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Storage devices have caches ({{c1::SRAM}} or {{c2::DRAM}}) to enhance performance, but cached data is {{c3::volatile}} and can be lost in a power outage.",
                ""
            ],
            "guid": "QK7tJtmU96",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "The order in which data is written to storage media can be unpredictable due to {{c1::caching}} and {{c2::queueing}} mechanisms.",
                ""
            ],
            "guid": "N7l3d0H-{:",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Two important hardware supports needed for crash recovery are {{c1::Flush}} and {{c2::Fence}}.",
                "<ul><li>Flush ensures data is written from cache to persistent media in a controlled manner</li><li>Fence provides more flexibility in controlling the order of data persistence without dictating the exact timing of writes<br></li></ul>"
            ],
            "guid": "MTAmmO;QY[",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Flush}} ensures data is written from cache to {{c2::persistent::ephemeral/persistent}} media in a controlled manner but are {{c3::coarse::fine/coarse}}-grained and may lead to inefficiencies",
                ""
            ],
            "guid": "H#g`HGR^gq",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Fence}} provides more {{c2::flexibility}} in controlling the order of data persistence without dictating the exact timing of writes",
                ""
            ],
            "guid": "x0uo0*q,89",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Efficient crash recovery requires control over the order of {{c2::IO operations}} and the timing of data {{c1::durability}}",
                ""
            ],
            "guid": "N[es1tV6e",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "In modern storage devices with persistent memory, Flush and Fence support exists, but older devices like hard drives may lack {{c1::Fence}} support",
                ""
            ],
            "guid": "j&I(Gxu-$.",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Fence}} instructions may be implemented using {{c2::Flush}} commands in devices without native {{c1::Fence}} support",
                ""
            ],
            "guid": "y+Gp[svW`{",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c3::BTFS::File system}} is a {{c1::copy-on-write}} file system that offers performing efficient {{c2::snapshot}}s and cloning",
                ""
            ],
            "guid": "dN<=M{#{YX",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::BTRFS}} uses {{c2::shadow paging}} where updates involve copying nodes from the leaf to the root and atomic commit point is when the new root is written",
                ""
            ],
            "guid": "EPp8]7$2;-",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::BTRFS::File system}} has the {{c2::wandering tree}} problem&nbsp;that is reduced by using&nbsp;{{c3::log}}-based {{c4::batch}} updates&nbsp;",
                "Wandering Tree Problem: Changes at lower levels of the tree propagate up, impacting performance. Minor updates may require modifying many nodes<br><br>Logging and batching updates reduces frequency of tree updates"
            ],
            "guid": "Bp&dbZVB:R",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c3::BTRFS::File system}} has {{c1::locallity}} issues caused by {{c2::frequent}} node allocation scattering data and reducing {{c4::read::read/write}} performance",
                ""
            ],
            "guid": "y}o$e2Jkn1",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c2::Shadow paging::Crash recovery technique}} uses&nbsp;{{c1::garbage collection}} to clean up unused nodes at the cost of performance",
                ""
            ],
            "guid": "NPE~A~M&Dx",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Logging::Crash recovery technique}} writes the data first to the {{c1::log}} then a {{c2::commit}} block is written",
                "The operations in the log can be replayed. Update before commit block is written are discarded on crash"
            ],
            "guid": "hHb`=##GER",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "Operations in the {{c1::log}} must be {{c2::idempotent}} so they can be replayed without affecting the result",
                ""
            ],
            "guid": "iH{^~mIt,z",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Write-ahead}}-/{{c2::redo}}-logging is when we write to the log first",
                "Used by xv6 and ext4"
            ],
            "guid": "A%dcd>@P.b",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Physical}} logging is when the whole block of memory is written into the log whereas {{c2::logical}} logging only stores the operations",
                "Logical locking saves log space but is more complex and prone to bugs"
            ],
            "guid": "x*w(X?]hiV",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "{{c1::Undo}}-logging makes a copy of existing data and throws away changes if it fails",
                "Slower than write-ahead. SQLite defaults to undo logging but can do both"
            ],
            "guid": "LHg/>#);zF",
            "note_model_uuid": "b21fc8a2-c337-11ee-ba01-25ef8c141b52",
            "tags": [
                "storage-virtualization"
            ]
        }
    ],
    "reviewLimit": null,
    "reviewLimitToday": null
}